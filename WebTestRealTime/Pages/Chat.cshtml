@page
@model WebTestRealTime.Pages.ChatModel
@using System.Text.Json
@{
    ViewData["Title"] = "Chat Test";
    var baseUrl = (ViewData["BaseUrl"] as string) ?? string.Empty;
    var email = (ViewData["Email"] as string) ?? string.Empty;
    var password = (ViewData["Password"] as string) ?? string.Empty;
}

<h1>Realtime Chat Test</h1>

<div class="alert alert-info mb-4" role="alert">
    <div class="d-flex align-items-center">
        <div class="me-3">
            <span id="connectionStatus" class="badge bg-secondary">Disconnected</span>
        </div>
        <div class="flex-grow-1">
            <small>Connection Status: <span id="connectionState">Not initialized</span></small>
        </div>
    </div>
</div>

<div class="mb-4">
    <h2>Login</h2>
    <form id="loginForm" class="row gy-2 gx-3 align-items-center">
        <div class="col-sm-4">
            <label class="form-label" for="emailInput">Email</label>
            <input id="emailInput" class="form-control" type="email" value="@email" readonly />
        </div>
        <div class="col-sm-4">
            <label class="form-label" for="passwordInput">Password</label>
            <input id="passwordInput" class="form-control" type="password" value="@password" readonly />
        </div>
        <div class="col-sm-4 d-flex align-items-end">
            <button type="submit" class="btn btn-primary me-2">Login</button>
            <button type="button" class="btn btn-outline-secondary" onclick="disconnect()">Disconnect</button>
        </div>
    </form>
    <p class="text-muted mt-2">Base URL: <code>@baseUrl</code></p>
</div>

<div class="mb-4">
    <h2>Direct Message</h2>
    <div class="row gy-2 gx-3 align-items-center">
        <div class="col-sm-4">
            <label class="form-label" for="otherUserId">Other User Id (GUID)</label>
            <input id="otherUserId" class="form-control" type="text" placeholder="00000000-0000-0000-0000-000000000000" />
        </div>
        <div class="col-sm-8 d-flex align-items-end gap-2 flex-wrap">
            <button type="button" class="btn btn-secondary" onclick="joinDm()">Join DM</button>
            <button type="button" class="btn btn-info" onclick="loadDmHistory()">Load DM History</button>
            <button type="button" class="btn btn-primary" onclick="sendDm()">Send DM</button>
        </div>
    </div>
    <div class="mt-3">
        <label class="form-label" for="message">Message</label>
        <input id="message" class="form-control" type="text" placeholder="Type a message" />
    </div>
</div>

<div class="mb-4">
    <h2>Room (optional)</h2>
    <div class="row gy-2 gx-3 align-items-center">
        <div class="col-sm-4">
            <label class="form-label" for="roomId">Room Id</label>
            <input id="roomId" class="form-control" type="text" placeholder="room-123" />
        </div>
        <div class="col-sm-8 d-flex align-items-end gap-2 flex-wrap">
            <button type="button" class="btn btn-secondary" onclick="joinRoom()">Join Room</button>
            <button type="button" class="btn btn-primary" onclick="sendRoom()">Send To Room</button>
        </div>
    </div>
</div>

<div class="mb-4">
    <div class="d-flex justify-content-between align-items-center">
        <h2>Log</h2>
        <button type="button" class="btn btn-sm btn-outline-danger" onclick="clearLog()">Clear Log</button>
    </div>
    <ul id="log" class="list-unstyled border rounded p-3 bg-light" style="min-height: 200px; max-height: 400px; overflow-y: auto;"></ul>
</div>

@section Scripts {
    <script>
        const BASE_URL = @JsonSerializer.Serialize(baseUrl);
        const EMAIL = @JsonSerializer.Serialize(email);
        const PASSWORD = @JsonSerializer.Serialize(password);

        let accessToken = null;
        let connection = null;
        let currentUser = null;

        const LogEntryType = Object.freeze({
            info: 'info',
            error: 'error'
        });

        function updateConnectionStatus(state, statusText) {
            const statusBadge = document.getElementById('connectionStatus');
            const stateText = document.getElementById('connectionState');
            
            if (stateText) stateText.textContent = state;
            
            if (statusBadge) {
                statusBadge.textContent = statusText || state;
                statusBadge.className = 'badge bg-secondary';
                
                if (state === 'Connected') {
                    statusBadge.className = 'badge bg-success';
                } else if (state === 'Connecting' || state === 'Reconnecting') {
                    statusBadge.className = 'badge bg-warning';
                } else if (state === 'Disconnected') {
                    statusBadge.className = 'badge bg-danger';
                }
            }
        }

        async function login() {
            console.log('Login button clicked!');
            console.log('BASE_URL:', BASE_URL);
            console.log('EMAIL:', EMAIL);
            
            appendLog('Logging in...', LogEntryType.info);
            try {
                console.log('Calling fetch...');
                const res = await fetch(BASE_URL + '/api/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userNameOrEmail: EMAIL, password: PASSWORD })
                });

                console.log('Response status:', res.status);
                console.log('Response:', res);

                if (!res.ok) {
                    const errorText = await res.text();
                    console.error('Login failed:', errorText);
                    throw new Error('Login failed: ' + res.status + ' ' + res.statusText + ' ' + errorText);
                }

                const json = await res.json();
                console.log('Login response:', json);
                accessToken = json.accessToken || json.AccessToken || null;

                if (!accessToken) {
                    throw new Error('No access token received from login response.');
                }

                appendLog('Login successful. Access token acquired.', LogEntryType.info);

                await connect();
            } catch (error) {
                console.error('Login error:', error);
                appendLog('Login error: ' + error.message, LogEntryType.error);
            }
        }

        async function connect() {
            if (!window.signalR) {
                appendLog('SignalR client library not found.', LogEntryType.error);
                return;
            }

            if (!accessToken) {
                appendLog('Cannot connect without access token. Please login first.', LogEntryType.error);
                return;
            }

            if (connection && connection.state === 'Connected') {
                appendLog('Already connected.', LogEntryType.info);
                return;
            }

            updateConnectionStatus('Connecting', 'Connecting...');

            connection = new signalR.HubConnectionBuilder()
                .withUrl(BASE_URL + '/ws/chat', { accessTokenFactory: () => accessToken })
                .withAutomaticReconnect()
                .build();

            connection.on('msg', (dto) => {
                const from = dto?.fromUserId ?? '?';
                const to = dto?.toUserId ?? dto?.roomId ?? '?';
                const text = dto?.text ?? '';
                const time = dto?.sentAt ? new Date(dto.sentAt).toLocaleTimeString() : '';
                appendLog('[MSG ' + time + '] From: ' + from + ' To: ' + to + ': ' + text, LogEntryType.info);
            });

            connection.on('history', (payload) => {
                const count = payload?.items?.length ?? 0;
                appendLog('[HISTORY] ' + count + ' items received.');
            });

            connection.onclose((error) => {
                updateConnectionStatus('Disconnected', 'Disconnected');
                appendLog('Connection closed' + (error ? ': ' + error.message : '') + '.', error ? LogEntryType.error : LogEntryType.info);
            });

            connection.onreconnecting((error) => {
                updateConnectionStatus('Reconnecting', 'Reconnecting...');
                appendLog('Reconnecting...' + (error ? ' ' + error.message : ''), LogEntryType.info);
            });

            connection.onreconnected((connectionId) => {
                updateConnectionStatus('Connected', 'Connected');
                appendLog('Reconnected. ConnectionId=' + (connectionId ?? 'unknown'), LogEntryType.info);
            });

            try {
                await connection.start();
                updateConnectionStatus('Connected', 'Connected');
                appendLog('Connected to /ws/chat. State: ' + getConnectionState(), LogEntryType.info);
            } catch (error) {
                updateConnectionStatus('Disconnected', 'Failed');
                appendLog('Connection failed: ' + error.message, LogEntryType.error);
            }
        }

        async function disconnect() {
            if (connection) {
                try {
                    await connection.stop();
                    updateConnectionStatus('Disconnected', 'Disconnected');
                    appendLog('Disconnected from /ws/chat.', LogEntryType.info);
                } catch (error) {
                    appendLog('Error disconnecting: ' + error.message, LogEntryType.error);
                }
            }
        }

        async function ensureMe() {
            if (currentUser) {
                return currentUser;
            }

            if (!accessToken) {
                throw new Error('Access token is required. Login first.');
            }

            const res = await fetch(BASE_URL + '/api/auth/me', {
                headers: { Authorization: 'Bearer ' + accessToken }
            });

            if (!res.ok) {
                const errorText = await res.text();
                throw new Error('Failed to fetch /api/auth/me: ' + res.status + ' ' + res.statusText + ' ' + errorText);
            }

            currentUser = await res.json();
            const currentId = currentUser?.id ?? currentUser?.Id ?? '(unknown)';
            appendLog('Current user: ' + currentId + '.', LogEntryType.info);
            return currentUser;
        }

        function unorderedDmChannel(a, b) {
            const values = [String(a ?? '').toLowerCase(), String(b ?? '').toLowerCase()].sort();
            return 'dm:' + values[0] + '_' + values[1];
        }

        async function joinDm() {
            try {
                await ensureConnected();
                const me = await ensureMe();
                const other = document.getElementById('otherUserId').value.trim();

                if (!other) {
                    throw new Error('Other user id is required.');
                }

                const meId = me?.id ?? me?.Id;
                if (!meId) {
                    throw new Error('Your user id could not be determined.');
                }

                const channel = unorderedDmChannel(meId, other);
                await connection.invoke('JoinChannels', [channel]);
                appendLog('Joined ' + channel + '.', LogEntryType.info);
            } catch (error) {
                appendLog('Join DM error: ' + error.message, LogEntryType.error);
            }
        }

        async function loadDmHistory() {
            try {
                await ensureConnected();
                const me = await ensureMe();
                const other = document.getElementById('otherUserId').value.trim();

                if (!other) {
                    throw new Error('Other user id is required.');
                }

                const meId = me?.id ?? me?.Id;
                if (!meId) {
                    throw new Error('Your user id could not be determined.');
                }

                const channel = unorderedDmChannel(meId, other);
                await connection.invoke('LoadHistory', channel, null, 50);
                appendLog('Requested history for ' + channel + '.', LogEntryType.info);
            } catch (error) {
                appendLog('Load history error: ' + error.message, LogEntryType.error);
            }
        }

        async function sendDm() {
            try {
                await ensureConnected();
                const other = document.getElementById('otherUserId').value.trim();
                const text = document.getElementById('message').value;

                if (!other) {
                    throw new Error('Other user id is required.');
                }

                if (!text) {
                    throw new Error('Message text is required.');
                }

                await connection.invoke('SendDm', other, text);
                appendLog('[SEND DM] -> ' + other + ': ' + text);
            } catch (error) {
                appendLog('Send DM error: ' + error.message, LogEntryType.error);
            }
        }

        async function joinRoom() {
            try {
                await ensureConnected();
                const id = document.getElementById('roomId').value.trim();
                if (!id) {
                    throw new Error('Room id is required.');
                }

                await connection.invoke('JoinChannels', ['room:' + id]);
                appendLog('Joined room:' + id + '.', LogEntryType.info);
            } catch (error) {
                appendLog('Join room error: ' + error.message, LogEntryType.error);
            }
        }

        async function sendRoom() {
            try {
                await ensureConnected();
                const id = document.getElementById('roomId').value.trim();
                const text = document.getElementById('message').value;

                if (!id) {
                    throw new Error('Room id is required.');
                }

                if (!text) {
                    throw new Error('Message text is required.');
                }

                await connection.invoke('SendToRoom', id, text);
                appendLog('[SEND ROOM] #' + id + ': ' + text);
            } catch (error) {
                appendLog('Send room error: ' + error.message, LogEntryType.error);
            }
        }

        async function ensureConnected() {
            if (!connection || connection.state !== 'Connected') {
                throw new Error('Connection is not active. Please login and connect first.');
            }
        }

        function appendLog(message, type = LogEntryType.info) {
            const log = document.getElementById('log');
            const li = document.createElement('li');
            const timestamp = new Date().toLocaleTimeString();
            li.textContent = '[' + timestamp + '] ' + (message ?? '');
            li.classList.add('small', 'mb-1');
            if (type === LogEntryType.error) {
                li.classList.add('text-danger', 'fw-bold');
            } else {
                li.classList.add('text-dark');
            }
            log.appendChild(li);
            log.scrollTop = log.scrollHeight;
        }

        function clearLog() {
            const log = document.getElementById('log');
            log.innerHTML = '';
            appendLog('Log cleared', LogEntryType.info);
        }

        function getConnectionState() {
            if (!connection) return 'Not initialized';
            return connection.state || 'Unknown';
        }

        document.getElementById('loginForm').addEventListener('submit', (event) => {
            event.preventDefault();
            login();
        });

        window.addEventListener('beforeunload', () => {
            if (connection) {
                connection.stop();
            }
        });

        window.joinDm = joinDm;
        window.sendDm = sendDm;
        window.loadDmHistory = loadDmHistory;
        window.joinRoom = joinRoom;
        window.sendRoom = sendRoom;
        window.disconnect = disconnect;
        window.clearLog = clearLog;
    </script>
}
